using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using DHUI.Core;

namespace DHUI
{
    /// <summary>
    /// This class simulates the Tracking of the Drone using the output values generated by the DroneController.
    /// </summary>
    public class DHUI_DroneTracking_Simulated_UsingOutput : DHUI_DroneTracking_Base
    {
        [Header("Setup")]

        [Tooltip("The drone controller. This is needed to simulate.")]
        public DHUI_DroneController m_droneController = null;

        [Tooltip("The drone controller's output. This is needed to get the actual output values.")]
        public DHUI_Output m_output = null;

        [Header("Settings")]

        public int _throttleHover = 1450;
        public float _throttleSensitivity = 0.001f;

        public int _rollHover = 1500;
        public float _rollSensitivity = 0.001f;

        public int _pitchHover = 1500;
        public float _pitchSensitivity = 0.001f;

        public int _yawHover = 1500;
        public float _yawSensitivity = 0.001f;

        public float _horizontalVelocitySensitivity = 0.001f;

        [Tooltip("Turn this on to simulate tracking lost.")]
        public bool _simulateTrackingLost = false;

        [Header("Info")]
        public int Throttle = 0;
        public int Roll = 0;
        public int Pitch = 0;
        public int Yaw = 0;
        
      
        protected override void UpdateTracker()
        {
            trackingOK = !_simulateTrackingLost;

            int[] currentVals = m_output.GetCurrentValues();


            trackedTransform.Rotate(trackedTransform.right, (currentVals[2] - _pitchHover) * _pitchSensitivity);
            trackedTransform.Rotate(trackedTransform.forward, (currentVals[1] - _rollHover) * -_rollSensitivity);
            trackedTransform.Rotate(trackedTransform.InverseTransformDirection(Vector3.up), (currentVals[3] - _yawHover) * _yawSensitivity);

            Vector3 translation = new Vector3(trackedTransform.up.x * _horizontalVelocitySensitivity, trackedTransform.up.y * (currentVals[0] - _throttleHover) * _throttleSensitivity, trackedTransform.up.z * _horizontalVelocitySensitivity);
            trackedTransform.Translate(translation);

            velocity = translation;

            Throttle = currentVals[0];
            Roll = currentVals[1];
            Pitch = currentVals[2];
            Yaw = currentVals[3];

            // Stop at floor
            Vector3 pos = trackedTransform.position;
            if (pos.y < 0) pos.y = 0;
            trackedTransform.position = pos;
        }
    }
}